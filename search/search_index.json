{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DSTA Project Documentation Setup Execute Instructions","title":"DSTA Project Documentation"},{"location":"#dsta-project-documentation","text":"Setup Execute Instructions","title":"DSTA Project Documentation"},{"location":"crazyswarm/","text":"Crazyswarm2 Setup in Highbay High-Level Steps Turn on the VICON (just flip the switch and wait for it to turn on!) Connect to VICON on the machine (run ros2 launch mocap vicon.launch.xml ) Position and turn on drones and plug in the Crazyradio Run program (a few times if needed) Retrieve drones and charge (if needed) (1) Turn on VICON The best guide on how to turn on the VICON is here . JUST FOLLOW STEPS 1-4 since we will be using the single-marker method. Make sure that the setup is live and looks a little like below: (2) Connect to VICON on the machine To allow Crazyswarm2 to access the information from VICON, run this in a terminal on the highbay machine: ros2 launch mocap vicon.launch.xml It should successfully connect to the highbay machine and you should get latency readings. Make sure to keep this running in the background when running programs! (3) Position and turn on drones and plug in the Crazyradio Plug in the Crazyradio into the desktop! Either Crazyradio works and any port works! Check out crazyswarm2/crazyflie/config/crazyflies.yaml . The top of the file should look something like this: robots: cf1: enabled: true uri: radio://0/80/2M/E7E7E7E701 initial_position: [0.0, 0.0, 0.0] type: cf21 cf2: enabled: true uri: radio://0/80/2M/E7E7E7E702 initial_position: [0.0, -1.0, 0.0] type: cf21 cf3: enabled: true uri: radio://0/80/2M/E7E7E7E703 initial_position: [0.0, 1.0, 0.0] type: cf21 To use less Crazyflies, change enabled: false . The axes of the highbay are like so: -x | | | -y ------------ +y | | | +x ---------------- | Control Room | ---------------- The control room box is where the computers are located (in the far +x, +y side). The below assumes you're at the control room box facing the -x direction. With the config file above, that means the crazyflies must be oriented like so: ------- ------- ------- | cf2 | |-- 1.0 units --| | cf1 | |-- 1.0 units --| | cf3 | ------- ------- ------- You can tell which crazyflie is which based on the number written on tape on the bottom of it. For example, under cf1, there is a tape with the number 1 and it corresponds to URI radio://0/80/2M/E7E7E7E701 . The ends of the table is about 1.0 units (technically a little more but that's okay). Place the crazyflies on opposite ends of the table and make sure it is flat. Orient the crazyflies with the red and black battery wire facing the -x direction (away from the control room). Alternatively, you can think that you should align the front of the drone with the +x axis (facing towards the control room). Finally, turn on the drones. Firstly, make sure NO CRAZYFLIE PROGRAM IS CURRENTLY RUNNING. Then press the button power button for both drones (order and timing doesn't really matter). The power button is what's labelled the \"reset button\" below. The crazyflie will automatically test all its motors by gently spinning them. If this does not happen within a minute of turning on, try again (and make sure no program is currently sending it signals)! Finally, close the velcro around the net so the crazyflies don't crash without the net! (4) Run program (a few times if needed) Execute the program. Check out the info here ! You may need to execute it a few times before it successfully connects (if it doesn't do anything after about a minute, then it's almost certainly not connected so just rerun it!). If it fails a ton of times or keeps on getting stuck at some part, restart the crazyflie. Here's a small compilation of errors I've run into and actions: Error Action Stuck on Requesting memories... Unplug and Replug the Crazyradio or Restart the Crazyflie (5) Retrieve drones and charge (if needed) After the crazyflies do its thing, you'll need to retrieve them! I go under the net and try to grab the crazyflies out of one of the many holes in it. To charge the crazyflie, connect it to a laptop using the USB-A to micro-USB cable. Make sure the battery is still plugged in. Turn on the crazyflie. It should have two blue lights with one of them flashing. While the light is flashing, it's being charged. If it's solid, it's done charging. REMEMBER: turn off the crazyflie before running code since it can still recieve signals while charging!! Debugging My crazyflie automatically crashed out when trying to do anything (hello_world, etc.) The axes are probably incorrect. Recall: -x | | | -y ------------ +y | | | +x ---------------- | Control Room | ---------------- Make the front of the drones facing +x. Also recall the position of the crazyflies (doesn't need to exactly 1.0 but roughly, about a table apart): ------- ------- ------- | cf2 | |-- 1.0 units --| | cf1 | |-- 1.0 units --| | cf3 | ------- ------- -------","title":"Crazyswarm2 Setup in Highbay"},{"location":"crazyswarm/#crazyswarm2-setup-in-highbay","text":"","title":"Crazyswarm2 Setup in Highbay"},{"location":"crazyswarm/#high-level-steps","text":"Turn on the VICON (just flip the switch and wait for it to turn on!) Connect to VICON on the machine (run ros2 launch mocap vicon.launch.xml ) Position and turn on drones and plug in the Crazyradio Run program (a few times if needed) Retrieve drones and charge (if needed)","title":"High-Level Steps"},{"location":"crazyswarm/#1-turn-on-vicon","text":"The best guide on how to turn on the VICON is here . JUST FOLLOW STEPS 1-4 since we will be using the single-marker method. Make sure that the setup is live and looks a little like below:","title":"(1) Turn on VICON"},{"location":"crazyswarm/#2-connect-to-vicon-on-the-machine","text":"To allow Crazyswarm2 to access the information from VICON, run this in a terminal on the highbay machine: ros2 launch mocap vicon.launch.xml It should successfully connect to the highbay machine and you should get latency readings. Make sure to keep this running in the background when running programs!","title":"(2) Connect to VICON on the machine"},{"location":"crazyswarm/#3-position-and-turn-on-drones-and-plug-in-the-crazyradio","text":"Plug in the Crazyradio into the desktop! Either Crazyradio works and any port works! Check out crazyswarm2/crazyflie/config/crazyflies.yaml . The top of the file should look something like this: robots: cf1: enabled: true uri: radio://0/80/2M/E7E7E7E701 initial_position: [0.0, 0.0, 0.0] type: cf21 cf2: enabled: true uri: radio://0/80/2M/E7E7E7E702 initial_position: [0.0, -1.0, 0.0] type: cf21 cf3: enabled: true uri: radio://0/80/2M/E7E7E7E703 initial_position: [0.0, 1.0, 0.0] type: cf21 To use less Crazyflies, change enabled: false . The axes of the highbay are like so: -x | | | -y ------------ +y | | | +x ---------------- | Control Room | ---------------- The control room box is where the computers are located (in the far +x, +y side). The below assumes you're at the control room box facing the -x direction. With the config file above, that means the crazyflies must be oriented like so: ------- ------- ------- | cf2 | |-- 1.0 units --| | cf1 | |-- 1.0 units --| | cf3 | ------- ------- ------- You can tell which crazyflie is which based on the number written on tape on the bottom of it. For example, under cf1, there is a tape with the number 1 and it corresponds to URI radio://0/80/2M/E7E7E7E701 . The ends of the table is about 1.0 units (technically a little more but that's okay). Place the crazyflies on opposite ends of the table and make sure it is flat. Orient the crazyflies with the red and black battery wire facing the -x direction (away from the control room). Alternatively, you can think that you should align the front of the drone with the +x axis (facing towards the control room). Finally, turn on the drones. Firstly, make sure NO CRAZYFLIE PROGRAM IS CURRENTLY RUNNING. Then press the button power button for both drones (order and timing doesn't really matter). The power button is what's labelled the \"reset button\" below. The crazyflie will automatically test all its motors by gently spinning them. If this does not happen within a minute of turning on, try again (and make sure no program is currently sending it signals)! Finally, close the velcro around the net so the crazyflies don't crash without the net!","title":"(3) Position and turn on drones and plug in the Crazyradio"},{"location":"crazyswarm/#4-run-program-a-few-times-if-needed","text":"Execute the program. Check out the info here ! You may need to execute it a few times before it successfully connects (if it doesn't do anything after about a minute, then it's almost certainly not connected so just rerun it!). If it fails a ton of times or keeps on getting stuck at some part, restart the crazyflie. Here's a small compilation of errors I've run into and actions: Error Action Stuck on Requesting memories... Unplug and Replug the Crazyradio or Restart the Crazyflie","title":"(4) Run program (a few times if needed)"},{"location":"crazyswarm/#5-retrieve-drones-and-charge-if-needed","text":"After the crazyflies do its thing, you'll need to retrieve them! I go under the net and try to grab the crazyflies out of one of the many holes in it. To charge the crazyflie, connect it to a laptop using the USB-A to micro-USB cable. Make sure the battery is still plugged in. Turn on the crazyflie. It should have two blue lights with one of them flashing. While the light is flashing, it's being charged. If it's solid, it's done charging. REMEMBER: turn off the crazyflie before running code since it can still recieve signals while charging!!","title":"(5) Retrieve drones and charge (if needed)"},{"location":"crazyswarm/#debugging","text":"My crazyflie automatically crashed out when trying to do anything (hello_world, etc.) The axes are probably incorrect. Recall: -x | | | -y ------------ +y | | | +x ---------------- | Control Room | ---------------- Make the front of the drones facing +x. Also recall the position of the crazyflies (doesn't need to exactly 1.0 but roughly, about a table apart): ------- ------- ------- | cf2 | |-- 1.0 units --| | cf1 | |-- 1.0 units --| | cf3 | ------- ------- -------","title":"Debugging"},{"location":"demos/","text":"Demonstrations for Delay-Kirk with Teams of Drones Hardware Demonstration Scenario Two teams A and B, each with 2 drones. Each destination is a communication hotspot i.e starts and ends of each drones are the only places where they can communicate with the command server or other teams. Communication with the command serve is reliable but unreliable with other teams Everywhere else is a dead-zone. A starts first and finishes its mission. A then uploads its data to the command server. Now here delay comes into play. Since A and B cannot talk directly to each other, the command server has to bridge that gap which introduces the delay. B starts after A finishes uploading its data to the command server. B repeats the same process as A until it finishes and uploads it data to the command server. Each demo will be supplemented by a simulation-only video in visual and non-visual environments as backup. Current setup is scalable to more teams and more drones within teams and more missions as well. Mission A: Time Bound - [lb_A, ub_A], Delay Bound - [dl_A, du_A] Upload A: Time Bound - [upl_A, upu_A] Mission B: Time Bound - [lb_B, ub_B], Delay Bound - [dl_B, du_B] Upload B: Time Bound - [upl_B, upu_B] Missions are contingent events i.e they need to be acknowledged. Let $d_A \\in [dl_A, du_A]$ be the delay after $t_A$ when team B receives the unreliable acknowledgement of team A. Let $t_A^B = min(ub_A, t_A + d_A)$ be the time when B receives the unreliable acknowledgement of team A. \"xxxxxxx\" denotes minimum bound of the communication delay i.e dl_A in this context. Timelines: t=0|---------------------------------------------------------------------------------------------------|t=$\\infty$ A's perspective: $lb_A$ $t_A$ $ub_A$ Mission A: |--------------|--------------------| | $t_A+upl_A$ | $t_A+upu_A$ Upload A: | |--------------------------------------| | | B's perspective: | | $t_A+dl_A$ $t_A+du_A$ Mission A: |xxxxx|----Case 1-----|---Case 2------| | Upload A: |xxxxx|--|--------------------------------------| $t_A^B + max(0, upl_A-dl_A)$ $t_A^B + max(0, upu_A-dl_A)$ Mission B: |-----------------------------|---------------------| $t_A^B + max(0, upl_A-dl_A) + lb_B$ | $t_A^B + max(0, upl_A-dl_A) + ub_B$ Upload B: |-------------------------| $t_B + upl_B$ $t_B + upu_B$ Objectives of the demos: First Demo: Behavior of Kirk/Delay-Kirk will be similar. Second Demo: Delay-Kirk will not crash in scenarios where the communication delay exceeds the mission duration bounds Third Demo: Delay-Kirk will be able to finish the overall mission faster due to its ability to compensate for communication delays Delay Kirk First Demo: No delay, Expected behavior: A starts and finishes, A communicates that it has finished and then B starts its mission and finishes [x] Sim [x] Hardware Second Demo: Non-zero delay, Cases are defined based on when B receives information about A's acknowledgement. Lets assume A finishes at $t_A \\in [lb_A, ub_A] Case 1: B receives A's ack within t_A^B \\in [t_A + dl_A, ub_A] Expected Behavior: B will start its mission at t_A^B [x] Sim [ ] Hardware Case 2: B receives A's ack within t_A^B \\in [ub_A, t_A + du_A] Expected Behavior: B will start its mission at ub_A + upl_A [x] Sim [ ] Hardware Third Demo: Non-zero large delays, Follow case 1 from previous demo, Expected behavior: Will finish the overall mission faster [x] Sim [ ] Hardware Kirk First Demo: No delay, Expected behavior: Same [ ] Sim [ ] Hardware Second Demo: Non-zero delay, Cases are defined based on when B receives information about A's acknowledgement. Lets assume A finishes at $t_A \\in [lb_A, ub_A] Case 1: B receives A's ack within t_A^B \\in [t_A + dl_A, ub_A] Expected Behavior: mission will finish later than delay-kirk [ ] Sim [ ] Hardware Case 2: B receives A's ack within t_A^B \\in [ub_A, t_A + du_A] Expected Behavior: planner will crash leading to failure of the overall mission [ ] Sim [ ] Hardware Third Demo: Non-zero large delays, Follow case 1 from previous demo, Expected behavior: Mission will finish much later than the corresponding delay-kirk demonstration [ ] Sim [ ] Hardware","title":"Demonstrations for Delay-Kirk with Teams of Drones"},{"location":"demos/#demonstrations-for-delay-kirk-with-teams-of-drones","text":"","title":"Demonstrations for Delay-Kirk with Teams of Drones"},{"location":"demos/#hardware-demonstration-scenario","text":"Two teams A and B, each with 2 drones. Each destination is a communication hotspot i.e starts and ends of each drones are the only places where they can communicate with the command server or other teams. Communication with the command serve is reliable but unreliable with other teams Everywhere else is a dead-zone. A starts first and finishes its mission. A then uploads its data to the command server. Now here delay comes into play. Since A and B cannot talk directly to each other, the command server has to bridge that gap which introduces the delay. B starts after A finishes uploading its data to the command server. B repeats the same process as A until it finishes and uploads it data to the command server. Each demo will be supplemented by a simulation-only video in visual and non-visual environments as backup. Current setup is scalable to more teams and more drones within teams and more missions as well. Mission A: Time Bound - [lb_A, ub_A], Delay Bound - [dl_A, du_A] Upload A: Time Bound - [upl_A, upu_A] Mission B: Time Bound - [lb_B, ub_B], Delay Bound - [dl_B, du_B] Upload B: Time Bound - [upl_B, upu_B] Missions are contingent events i.e they need to be acknowledged. Let $d_A \\in [dl_A, du_A]$ be the delay after $t_A$ when team B receives the unreliable acknowledgement of team A. Let $t_A^B = min(ub_A, t_A + d_A)$ be the time when B receives the unreliable acknowledgement of team A. \"xxxxxxx\" denotes minimum bound of the communication delay i.e dl_A in this context. Timelines: t=0|---------------------------------------------------------------------------------------------------|t=$\\infty$ A's perspective: $lb_A$ $t_A$ $ub_A$ Mission A: |--------------|--------------------| | $t_A+upl_A$ | $t_A+upu_A$ Upload A: | |--------------------------------------| | | B's perspective: | | $t_A+dl_A$ $t_A+du_A$ Mission A: |xxxxx|----Case 1-----|---Case 2------| | Upload A: |xxxxx|--|--------------------------------------| $t_A^B + max(0, upl_A-dl_A)$ $t_A^B + max(0, upu_A-dl_A)$ Mission B: |-----------------------------|---------------------| $t_A^B + max(0, upl_A-dl_A) + lb_B$ | $t_A^B + max(0, upl_A-dl_A) + ub_B$ Upload B: |-------------------------| $t_B + upl_B$ $t_B + upu_B$","title":"Hardware Demonstration Scenario"},{"location":"demos/#objectives-of-the-demos","text":"First Demo: Behavior of Kirk/Delay-Kirk will be similar. Second Demo: Delay-Kirk will not crash in scenarios where the communication delay exceeds the mission duration bounds Third Demo: Delay-Kirk will be able to finish the overall mission faster due to its ability to compensate for communication delays","title":"Objectives of the demos:"},{"location":"demos/#delay-kirk","text":"First Demo: No delay, Expected behavior: A starts and finishes, A communicates that it has finished and then B starts its mission and finishes [x] Sim [x] Hardware Second Demo: Non-zero delay, Cases are defined based on when B receives information about A's acknowledgement. Lets assume A finishes at $t_A \\in [lb_A, ub_A] Case 1: B receives A's ack within t_A^B \\in [t_A + dl_A, ub_A] Expected Behavior: B will start its mission at t_A^B [x] Sim [ ] Hardware Case 2: B receives A's ack within t_A^B \\in [ub_A, t_A + du_A] Expected Behavior: B will start its mission at ub_A + upl_A [x] Sim [ ] Hardware Third Demo: Non-zero large delays, Follow case 1 from previous demo, Expected behavior: Will finish the overall mission faster [x] Sim [ ] Hardware","title":"Delay Kirk"},{"location":"demos/#kirk","text":"First Demo: No delay, Expected behavior: Same [ ] Sim [ ] Hardware Second Demo: Non-zero delay, Cases are defined based on when B receives information about A's acknowledgement. Lets assume A finishes at $t_A \\in [lb_A, ub_A] Case 1: B receives A's ack within t_A^B \\in [t_A + dl_A, ub_A] Expected Behavior: mission will finish later than delay-kirk [ ] Sim [ ] Hardware Case 2: B receives A's ack within t_A^B \\in [ub_A, t_A + du_A] Expected Behavior: planner will crash leading to failure of the overall mission [ ] Sim [ ] Hardware Third Demo: Non-zero large delays, Follow case 1 from previous demo, Expected behavior: Mission will finish much later than the corresponding delay-kirk demonstration [ ] Sim [ ] Hardware","title":"Kirk"},{"location":"execute/","text":"Execute Code on Highbay This is a series of commands used on the highbay machines. One time: export PYTHONPATH=/home/mers/Developer/cc-sorb-rev:$PYTHONPATH Regularly: ros2 launch rbmapf_gzsim group_integrated_sim_demo.launch.py num_drones:=4 team_size:=2 use_hardware:=True Order: | 2 | 4 | 3 | 1 | ---------------- | Control Room | ---------------- Archive ros2 launch rbmapf_gzsim integrated_sim_demo.launch.py num_drones:=4 backend:=sim use_hardware:=False Edit the rmpl passed in Multi-drone, multi-mission distributed Kirk Launch the main crazyswarm launch.py with cflib ros2 launch crazyflie launch.py backend:=cflib Start the middleware server cd /home/mers/Developer/kirk_setup source venv/bin/activate python3 distr.py Run the crazyflies, wait till they're hovering bash execute.sh Run Kirk podman start 3d2642905d0e podman exec -it 3d2642905d0e /bin/bash bash execute_kirk.sh Run the Multi-Drone Planner podman start 3d2642905d0e podman exec -it 3d2642905d0e /bin/bash kirk run kirk-v2/examples/drone-case/easy.lisp -P scenario1 --driver-command 'curl -X POST -H \"Content-Type: application/json\" -d \"{\\\"data1\\\":\\\"~A\\\", \\\"data2\\\":\\\"~A\\\"}\" http://localhost:5000/submit' --tolerance 0.5 -p 8000 --verbose & cd /home/mers/Developer/kirk_setup source venv/bin/activate python3 main.py ros2 launch crazyflie_examples launch.py script:=hello_world backend:=cflib","title":"Execute Code on Highbay"},{"location":"execute/#execute-code-on-highbay","text":"This is a series of commands used on the highbay machines. One time: export PYTHONPATH=/home/mers/Developer/cc-sorb-rev:$PYTHONPATH Regularly: ros2 launch rbmapf_gzsim group_integrated_sim_demo.launch.py num_drones:=4 team_size:=2 use_hardware:=True Order: | 2 | 4 | 3 | 1 | ---------------- | Control Room | ----------------","title":"Execute Code on Highbay"},{"location":"execute/#archive","text":"ros2 launch rbmapf_gzsim integrated_sim_demo.launch.py num_drones:=4 backend:=sim use_hardware:=False Edit the rmpl passed in","title":"Archive"},{"location":"execute/#multi-drone-multi-mission-distributed-kirk","text":"Launch the main crazyswarm launch.py with cflib ros2 launch crazyflie launch.py backend:=cflib Start the middleware server cd /home/mers/Developer/kirk_setup source venv/bin/activate python3 distr.py Run the crazyflies, wait till they're hovering bash execute.sh Run Kirk podman start 3d2642905d0e podman exec -it 3d2642905d0e /bin/bash bash execute_kirk.sh","title":"Multi-drone, multi-mission distributed Kirk"},{"location":"execute/#run-the-multi-drone-planner","text":"podman start 3d2642905d0e podman exec -it 3d2642905d0e /bin/bash kirk run kirk-v2/examples/drone-case/easy.lisp -P scenario1 --driver-command 'curl -X POST -H \"Content-Type: application/json\" -d \"{\\\"data1\\\":\\\"~A\\\", \\\"data2\\\":\\\"~A\\\"}\" http://localhost:5000/submit' --tolerance 0.5 -p 8000 --verbose & cd /home/mers/Developer/kirk_setup source venv/bin/activate python3 main.py ros2 launch crazyflie_examples launch.py script:=hello_world backend:=cflib","title":"Run the Multi-Drone Planner"},{"location":"podman_stuff/","text":"Podman Loading podman commit IMAGE_NAME kirk-img:latest podman save -o kirk_img.tar kirk-img:latest podman load -i kirk_img.tar podman run -it localhost/kirk-img:latest /bin/bash sbcl (asdf:load-system \"kirk-v2\")","title":"Podman Loading"},{"location":"podman_stuff/#podman-loading","text":"podman commit IMAGE_NAME kirk-img:latest podman save -o kirk_img.tar kirk-img:latest podman load -i kirk_img.tar podman run -it localhost/kirk-img:latest /bin/bash sbcl (asdf:load-system \"kirk-v2\")","title":"Podman Loading"}]}